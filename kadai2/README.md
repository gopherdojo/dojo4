# 課題2-1 io.Readerとio.Writerについて
## 何に使われているか
使われているパッケージは多い。一例として以下のようなものがある。
- os.File
- strings.NewReader
- http.Request.Body
- bytes.Buffer
- ioutil.ReadAll

これらのメソッドで、引数として使われていることが多い。

## どのような利点があるのか
最大の特長は、対象を限定せずに「読む/書く」という処理を抽象化したことにある。文字列だけではなく、ファイルやhttpリクエストもio.Reader・io.Writerで処理することができる。
こうすることで、読み書きのみを責務として担う関数を使いまわすことができる。Golangのinterfaceは型の一種なので、例えば後ろから一定の文字数だけ読むtailという関数があった場合、引数をio.Readerにすれば、文字列もファイルも同じtail関数で読めるようになる。テストするときも、読み出し部分のテストは1つのメソッドについて行えばよい。
また、より効率の良い読み方を求めて新しいnewTail関数を作ったとしても、その関数以外の部分に手を加える必要がなく、リファクタリングが最小限で済む。
このように、interfaceを上手に定義しておくことで、読む/書くための関数とそれ以外の関数をより疎結合に近い状態にしやすくなる。

上記はinterface一般にいえるメリットだが、io.Reader・io.Writerならではの良い点は、interfaceの中に定義されている関数が1つしかなく、それでいて意味的にも関数1つで過不足がないことにある。よけいな関数を定義しすぎてinterfaceが肥大化すると、後々そのinterfaceを使った新しいstructを定義するときに、必要性の薄い関数も改めて書かなければならず足を引っ張ることになりやすい。io.Reader・io.Writerは、Read/Write関数を定義しさえすれば使えるので、コードを書く側にとってもほとんど邪魔にならない。

# 課題2-2
## リファクタリング
- 画像変換の入り口のメソッドであるsearchFile関数に返り値を持たせた。
  - もともとは返り値を持たず、変換を実行するconvFile関数の返り値(=新しいパス)を最後にprintlnするだけだったが、新しいパス自体を返り値とする方が、searchFile関数の結果を取得してテストする処理を書きやすい気がした。

- 変換用関数convFileをテストしやすくするために、os.Removeを変換用の関数から外に出した(元ファイルが消えてしまうので非常にやりにくい)

- ファイルの再帰的探索と変換処理とを分離させた。これまでは一つファイルを見つけてはその場で変換をしていたが、変換対象のファイルを全部見つけた後にまとめて変換することで、探索と変換の両方をテストしやすくした。

- 関数内でエラー時にlog.Fatalですぐ終了しまうのをやめ、errorを返り値として返し、呼び出し元でエラーの中身を見て終了するようにした
	- すると、関数の戻り値としてエラーを受け取ってテストできる。どのエラーになったかもテストしやすい。 

## ヘルパー関数
- 各テスト関数に設置した。

## テーブル駆動テスト
- convFileのテストで使用している。

## カバレッジ
```
go test -coverprofile=cover.out 
go tool cover -html=cover.out -o cover.html
```